{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/230219_til/","result":{"data":{"site":{"siteMetadata":{"title":"MHLab blog","author":"MHLab","siteUrl":"https://elfinlas.github.io","comment":{"disqusShortName":"","utterances":"elfinlas/blog_utterances"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"e28d2431-b648-5ca0-9bf2-58d6c886557b","excerpt":"이중 로그인(중복 로그인) 문제를 해결하는 과정 흑우집합소는 정책 상 이중 로그인을 허용하지 않기로 정했다. 예를 들어 A라는 사용자가 크롬에서 로그인하고, 다시 사파리에서 로그인을 했을 때 이를 이중 로그인이라 칭한다. 뭐 개발좀 해본 사람이라면 다들 알것이다. 근데 계정 로그인 이후 단순하게 정보를 열람하거나, Read성향에 촛점이 맞춰진 서비스라면 이중 로그인은 문제가 되지 않는다. 하지만 내가 개발하는 흑우집합소는 추후 게시글 작성 기능 등 Create와 Update 그리고 Delete…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 895px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/39caabbd44b8d6bf6560fecef746ecb3/b002d/thumbnail_til.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABMklEQVQoz42SW2/CMAyFk7a50Li3lFJGuw2plSbxBP//x50lhjFAo+zhyI3lfj5xLIQQuJW3hKFaY3AeH7TGO7X4KNb4LDvsqw2rLxpsihqFdXj8XzwmIkBl6q9CVioTUGpQpZbhVpllYHRm9W9R13WYpgm7YUDj/V3tJq9QG7cMjNdTaXY9O+cwjiODiYhzUshzs1WJZkXLwDirNEnuclJK1mNtawg+L5eBcS5xTj8grTW7LIoCeZ4juWnmtUPryn84vADjFed5xuFwwOl4Cjpyg6tDTQFYvXAYgEadXzm6SbMwTylYqb5//SY47KheBva2xNy88S6KRKIOQ9+VLbZh93pq+Pt89tjXPXJtl4FXcHjBr24EmRVyqeASzSKOiqOR2evFlpdIymJqtk8X/Jm+AaC961594rpnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/39caabbd44b8d6bf6560fecef746ecb3/77434/thumbnail_til.webp 300w,\n/static/39caabbd44b8d6bf6560fecef746ecb3/411c4/thumbnail_til.webp 600w,\n/static/39caabbd44b8d6bf6560fecef746ecb3/dd3ab/thumbnail_til.webp 895w\"\n              sizes=\"(max-width: 895px) 100vw, 895px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/39caabbd44b8d6bf6560fecef746ecb3/a8a0d/thumbnail_til.png 300w,\n/static/39caabbd44b8d6bf6560fecef746ecb3/dface/thumbnail_til.png 600w,\n/static/39caabbd44b8d6bf6560fecef746ecb3/b002d/thumbnail_til.png 895w\"\n            sizes=\"(max-width: 895px) 100vw, 895px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/39caabbd44b8d6bf6560fecef746ecb3/b002d/thumbnail_til.png\"\n            alt=\"thumbnail\"\n            title=\"thumbnail\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<h1 id=\"이중-로그인중복-로그인-문제를-해결하는-과정\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A4%91-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%A4%91%EB%B3%B5-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"이중 로그인중복 로그인 문제를 해결하는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이중 로그인(중복 로그인) 문제를 해결하는 과정</h1>\n<p><a href=\"https://bcow.world\">흑우집합소</a>는 정책 상 이중 로그인을 허용하지 않기로 정했다.<br>\n예를 들어 A라는 사용자가 크롬에서 로그인하고, 다시 사파리에서 로그인을 했을 때 이를 <strong>이중 로그인</strong>이라 칭한다.</p>\n<p>뭐 개발좀 해본 사람이라면 다들 알것이다.<br>\n근데 계정 로그인 이후 단순하게 정보를 열람하거나, <strong>Read</strong>성향에 촛점이 맞춰진 서비스라면 이중 로그인은 문제가 되지 않는다.</p>\n<p>하지만 내가 개발하는 <a href=\"https://bcow.world\">흑우집합소</a>는 추후 게시글 작성 기능 등 <strong>Create</strong>와 <strong>Update</strong> 그리고 <strong>Delete</strong>기능을 가진다.<br>\n이 경우 이중 로그인 문제는 고려해야 할 문제다.</p>\n<h2 id=\"어떤-부분을-고려해야-할까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%A4-%EB%B6%80%EB%B6%84%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"어떤 부분을 고려해야 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떤 부분을 고려해야 할까?</h2>\n<p>먼저 개발하는 서비스의 로그인 방식부터 확인해봐야 할 것이다.<br>\n로그인 방식에는 다양한 방법이 존재한다.</p>\n<p>그리고 그 로그인 방식에 따라 이중 로그인 처리 방법이 약간 다르고,<br>\n처리하는 방식이 쉬울수도, 까다로울 수도 있다.</p>\n<blockquote>\n<p><strong>여기 아래서 부터는 Next.Js 기준으로 설명을 진행한다.</strong></p>\n</blockquote>\n<br>\n<h3 id=\"서버-세션-방식\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B2%84-%EC%84%B8%EC%85%98-%EB%B0%A9%EC%8B%9D\" aria-label=\"서버 세션 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버 세션 방식</h3>\n<p>만약 로그인 방식이 고전 클래식 스타일인 서버 세션에 저장하는 방식이라면 구현이 더 용이할 것이다.</p>\n<p>왜냐하면 로그인 정보를 세션에 넣어두고, 새로운 로그인 정보가 올 경우 기존에 있는 정보는 무효화 하면 되기 때문이다.<br>\n한가지 포인트는 <strong>서버 세션에 무엇을 넣는가?</strong>인데 일단 서비스마다 로그인 정보는 다르니까 이 부분은 넘긴다.</p>\n<p>어떤 정보인지는 아래서 자세히 다뤄보겠다.<br>\n단지 간단히 언급하면 <strong>클라이언트의 고유 값</strong>이 필요하다는 것이다.<br>\n이는 아래의 <a href=\"https://elfinlas.github.io/til/230219_til/#%EC%84%9C%EB%B2%84-%EB%82%B4-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0\">서버 내 저장하는 데이터</a>세션을 참고하자.</p>\n<br>\n<h3 id=\"sns-로그인-방식\" style=\"position:relative;\"><a href=\"#sns-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%B0%A9%EC%8B%9D\" aria-label=\"sns 로그인 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SNS 로그인 방식</h3>\n<p>이 경우 SNS 로그인 방식의 구현 방법에 따라 약간 까다로울 수 있다.<br>\n구글, 애플, 네이버 등 SNS 로그인을 제공하는 OAuth를 통해서 로그인을 진행한 경우 로그인 정보를 받고 <strong>JWT</strong>를 제공받을 것이다.</p>\n<p>보통은 JWT를 많이 준다.<br>\n많이 사용하는 Access와 Refresh 두 가지를 이용하는 방식이다.</p>\n<p>근데 서비스 내에서 사용자 정보를 보관하지 않거나, 간단하게 정보만 받는 경우는 매우 드물고…<br>\n보통 사용자 정보를 서비스 내에 저장하고 두기 때문에 위에서 언급한 방법과 유사하게 구현이 된다.</p>\n<p>OAuth에서 제공하는 JWT를 사용하는 경우 서버 세션에 해당 JWT정보를 주고,<br>\n다른 브라우저에서 로그인 한 경우 서버에서 저장한 JWT를 비교하는 방식으로 기존에 로그인 한 정보를 파기할 수 있다.</p>\n<p>만약 JWT 검증을 OAuth측에 맡길 경우 이 부분은 서버측에서 다른 이중 로그인 관련 정보를 들고 있어야 한다.</p>\n<p>하지만 OAuth측에서 제공하는 사용자 정보만 받고 보안 인증을 직접 운영한다면,<br>\n위의 서버 세션 방식이나 아래의 JWT 방식을 사용할 것이다.</p>\n<br>\n<h3 id=\"jwt-방식\" style=\"position:relative;\"><a href=\"#jwt-%EB%B0%A9%EC%8B%9D\" aria-label=\"jwt 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 방식</h3>\n<p>만약 서버 세션 방식을 사용하지 않고, 토큰 방식 중 하나인 <strong>JWT</strong>를 사용하는 경우 생각할 게 많아진다.<br>\nJWT는 한번 발급을 하면 서버측에서 제어할 수 없다.</p>\n<p>의존할 것은 JWT 내에 있는 <strong>Expired Date</strong>에 의존할 수 밖에 없다.<br>\n근데 이중 로그인은 저 만료시간이 중요하지 않다.</p>\n<p>언제 로그인을 할 지는 무작위로 발생하기 때문이다.<br>\n그래서 많은 고민이 드는 방법이다.</p>\n<p>내 개인적인 경험 바운더리 안에서 <strong>순수 JWT를 사용할 경우 이중 로그인을 막을 수 없다.</strong><br>\n그래서 서버 세션을 쓰던 디비에서 로그인 정보를 관리하던 해야 한다.</p>\n<p>이럴 경우 JWT를 쓰는 의미는 사라진다.<br>\n로그인 정보를 서버 내에 있는 자원(세션, 디비)에 의존하지 않으려 사용한 것이기 때문이다.</p>\n<p>그래서 JWT를 쓰는 경우 <strong>이중 로그인을 막으려면 결국 서버 자원에 의존할 수 밖에 없다.</strong></p>\n<br>\n<h2 id=\"서버-내-저장하는-데이터\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B2%84-%EB%82%B4-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"서버 내 저장하는 데이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버 내 저장하는 데이터</h2>\n<p>서비스마다 로그인 고유 정보는 다르니 빼기로 하고…<br>\n그럼 해당 브라우저로 접근했을 때 A와 B 로그인 정보가 다름을 확인하는 <strong>고유 값</strong>은 어떻게 만들어야 하는 것인가?</p>\n<p>필자는 아래와 같은 고민을 하면서 방법을 찾아봤다.</p>\n<br>\n<h3 id=\"useragent\" style=\"position:relative;\"><a href=\"#useragent\" aria-label=\"useragent permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UserAgent</h3>\n<p>중요한 것은 클라이언트를 구분하는 정보인데, 보통 생각하면 <strong>UserAgent</strong> 값을 생각할 수 있다.<br>\n<strong>UserAgent</strong>는 사용자의 브라우저 정보를 담고 있다.</p>\n<p>그래서 로그인 정보에 UserAgent를 담아볼까 생각했다.<br>\n하지만 이건 좋은 방법은 아니다.</p>\n<p>근데 만약 크롬의 새로운 윈도우 또는 다른 방식으로 띄울 경우 <strong>UserAgent</strong>는 유일한 값이 아닐 수 있다.<br>\n웹개발자라면 명심하겠지만 <strong>절대 사용자를 믿지 말라</strong> 라는 말을 기억할 것이다.</p>\n<p>그래서 UserAgent는 고유 값으로 쓸 수 없기에 이는 빼기로 했다.</p>\n<br>\n<h3 id=\"토큰-또는-uuid고유-식별자\" style=\"position:relative;\"><a href=\"#%ED%86%A0%ED%81%B0-%EB%98%90%EB%8A%94-uuid%EA%B3%A0%EC%9C%A0-%EC%8B%9D%EB%B3%84%EC%9E%90\" aria-label=\"토큰 또는 uuid고유 식별자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>토큰 또는 UUID(고유 식별자)</h3>\n<blockquote>\n<p>일종의 토큰을 생성해서 로그인 시 서버로 전달한다면?</p>\n</blockquote>\n<p>이 생각이 들었다.<br>\n그래서 이 방식을 접목하려 했다.</p>\n<p>먼저 고려해야 할 것은 <strong>토큰을 생성해주는 주체는 어디가 되어야 하는가?</strong> 이다.</p>\n<p>서버로 올 경우 매번 로그인 페이지에 접근할 때 토큰을 서버에게 요청해야 한다. (Axios 등으로)\n그리고 SNS 로그인을 사용할 경우 약간의 문제가 생긴다.</p>\n<p>SNS 로그인 방식을 사용할 경우 해당 OAuth 주체에게 그 정보를 어떻게 제공해야 하는가가 문제였다.<br>\n<strong>헤더에 정보를 넣어서 보내봤는데 정보가 제대로 안왔고, 추후 OAuth 주체가 정책을 변경하면 문제가 생긴다.</strong></p>\n<p>그럼 클라이언트에서 정보를 생성한다면?<br>\n근데 결국 클라이언트도 SNS 로그인 방식 때문에 위와 같은 문제에 봉착한다.\n그렇다면 어떻게 해야 할까?</p>\n<br>\n<h2 id=\"해결-방법을-찾다\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%B0%BE%EB%8B%A4\" aria-label=\"해결 방법을 찾다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해결 방법을 찾다.</h2>\n<blockquote>\n<p>SNS 로그인 방식으로 설명한다.<br>\n다른 방법은 그냥 서버에 정보를 저장하면 끝이기 때문이다.<br>\n단 서버에 어떤 정보를 저장하는지 관점으로 보면 좋을 듯 하다.</p>\n</blockquote>\n<p>일단 일차적으로 찾은 방법은…<br>\n<strong>SNS 로그인 이후 콜백에서 클라이언트로 정보를 보낼 때 서버측에서 토큰이나 UUID 정보를 전달</strong>하는 방법이었다.</p>\n<p>그리고 저 토큰이나 UUID를 쿠키나 로컬 스토리지에 저장하고, 서버와 통신할 때 헤더에 같이 보내면 된다.<br>\n근데 이렇게 할 경우 이런 문제가 발생할 수 있다.</p>\n<blockquote>\n<ol>\n<li>악의를 가진 사용자가 서버에서 온 토큰 또는 UUID를 탈취해서 사용할 경우?</li>\n<li>토큰이나 UUID 자체가 평문이라 복사해서 바로 사용할 수 있다면?</li>\n</ol>\n</blockquote>\n<p>그래서 나는 몇 가지 고민을 하다가 아래와 같은 스텝을 생각해봤다.<br>\n프론트, 백엔드 둘 다 약간의 작업이 필요하다.</p>\n<br>\n<h3 id=\"1-프론트엔드-측-토큰-생성\" style=\"position:relative;\"><a href=\"#1-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B8%A1-%ED%86%A0%ED%81%B0-%EC%83%9D%EC%84%B1\" aria-label=\"1 프론트엔드 측 토큰 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 프론트엔드 측 토큰 생성</h3>\n<p>초기 페이지에 들어오면 프론트엔드측에서 토큰을 하나 만들어서 LocalStorage와 쿠키에 저장을 해둔다.<br>\n토큰은 암호화(해시 아님)해서 저장한다.</p>\n<p>쿠키를 사용하는 이유는 Next.Js에서 ServerSide 측에서 처리할 때 LocalStorage 쪽은 접근할 수 없다.<br>\n하지만 쿠키는 접근이 가능하기에 두 영역에 저장을 해준다.</p>\n<p>참고로 <a href=\"https://github.com/vvo/iron-session\">Iron-Session</a> 등을 사용하면 보안 처리에 더 수월하다.</p>\n<p>암호화 하는 이유는 위에서 언급한 문제를 막기 위해서이다.<br>\n흑우집합소는 Next.Js를 사용하는데 <strong>app.tsx</strong>에서 아래 일련의 작업을 수행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//B-Code가 없다면 심어준다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isExistKeyInLocalStorage</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LOCAL_STORAGE_KEY_B_CODE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> encryptBCode <span class=\"token operator\">=</span> <span class=\"token function\">cryptoEncrypt</span><span class=\"token punctuation\">(</span><span class=\"token function\">makeClientBCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">setLocalStorageData</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LOCAL_STORAGE_KEY_B_CODE</span><span class=\"token punctuation\">,</span> encryptBCode<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">makeClientCookie</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b-code'</span><span class=\"token punctuation\">,</span> encryptBCode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">//존재하면 쿠키로 구워준다.</span>\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> bCode <span class=\"token operator\">=</span> <span class=\"token function\">getLocalStorageData</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LOCAL_STORAGE_KEY_B_CODE</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">makeClientCookie</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b-code'</span><span class=\"token punctuation\">,</span> bCode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위에서 <strong>b-code</strong>라는 것이 이중로그인을 막기 위한 토큰 역할을 하는 값이다.<br>\n이는 다른 방식으로 구현해도 무방하다.</p>\n<br>\n<h3 id=\"2-사용자의-로그인-수행\" style=\"position:relative;\"><a href=\"#2-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9D%98-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%88%98%ED%96%89\" aria-label=\"2 사용자의 로그인 수행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 사용자의 로그인 수행</h3>\n<p>사용자가 로그인 페이지에 접근해서 SNS 로그인을 실행한다.<br>\n여기선 특별한 작업은 없다.</p>\n<br>\n<h3 id=\"3-백엔드-측-sns-로그인-처리\" style=\"position:relative;\"><a href=\"#3-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%B8%A1-sns-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC\" aria-label=\"3 백엔드 측 sns 로그인 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 백엔드 측 SNS 로그인 처리</h3>\n<p>백엔드에서는 SNS 로그인 콜백을 받은 이후 해당 사용자의 서버측 토큰을 하나 생성해서 로그인 정보와 함께 프론트단에 보내준다.</p>\n<p>SNS 로그인 콜백에서 각 정보를 처리하는 과정에서 세션이나 디비에 사용자 정보를 넣을 때 백엔드 토큰을 담아준다.<br>\n구현방식에 따라 다르겠지만 마지막 로그인 정보(LastLoginInfo) 등을 세션이나 디비에 사용할 것이다.</p>\n<br>\n<h3 id=\"4-프론트엔드에서-sns-로그인-결과-수신\" style=\"position:relative;\"><a href=\"#4-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-sns-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B2%B0%EA%B3%BC-%EC%88%98%EC%8B%A0\" aria-label=\"4 프론트엔드에서 sns 로그인 결과 수신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 프론트엔드에서 SNS 로그인 결과 수신</h3>\n<p>클라이언트는 로그인 정보 수신 후 바로 Axios를 통해 1번에서 생성한 클라이언트 측 토큰을 보내준다.<br>\n이 작업은 Next.Js의 서버사이드 측(Route Api)에서 작업이 진행된다.</p>\n<p>보통 SNS 로그인은 창을 띄우던 내부 페이지를 쓰던 Get 메서드로 서버측 URL을 호출하게 된다.<br>\n그리고 서버측에서 SNS 콜백 처리 후 프론트엔드 측의 특정 페이지를 호출하게 한다.</p>\n<p>흑우집합소의 경우 <strong>Next.Js</strong>를 사용하여, <strong>Route Api</strong>쪽으로 정보를 전달한다.\n그리고 여기서 정상적으로 로그인 정보를 수신했다면, Axios를 통해서 서버측에 암호화된 클라이언트 토큰을 보내준다.</p>\n<br>\n<h3 id=\"5-백엔드의-마지막-로그인-정보-변경\" style=\"position:relative;\"><a href=\"#5-%EB%B0%B1%EC%97%94%EB%93%9C%EC%9D%98-%EB%A7%88%EC%A7%80%EB%A7%89-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%A0%95%EB%B3%B4-%EB%B3%80%EA%B2%BD\" aria-label=\"5 백엔드의 마지막 로그인 정보 변경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 백엔드의 마지막 로그인 정보 변경</h3>\n<p>서버측에서 프론트엔드의 토큰 정보를 받으면 복호화 후 이를 조합해서 <strong>클라이언트 고유의 값</strong>을 만들어서 저장한다.<br>\n그리고 디비 또는 세션에 정보를 갱신 후 프론트엔드 측으로 돌려준다.</p>\n<p>물론 당연한 이야기겠지만 https를 사용해도 이 값은 암호화 해주는 것이 좋다.<br>\n프론트엔드에서는 받은 값을 복호화 후 이를 LocalStorage와 Cookie에 갱신해준다.</p>\n<br>\n<h3 id=\"6-데이터-전송-시\" style=\"position:relative;\"><a href=\"#6-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1-%EC%8B%9C\" aria-label=\"6 데이터 전송 시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 데이터 전송 시</h3>\n<p>이제 저 값을 프론트엔드에서 가지고 있다가 Axios 등으로 통신을 할 때 헤더에 같이 실어서 보내면 된다.<br>\n그리고 서버 측에서는 헤더 값을 JWT 확인할 때 같이 이중 로그인도 확인하면 된다.</p>\n<br>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>코드가 없이 구구절절 설명으로만 적어서 이해가 약간 까다로울 수 있다.<br>\n근데 내가 사용하는 코드를 다 공개하기엔 내가 못찾은 취약점이 발견될 수도 있고,<br>\n보안상 외부에 노출되는 것은 좋지 않기에 이 부분은 양해를 구한다.</p>\n<p>근데 이 정도 설명만으로도 이중 로그인 해결에 실마리를 얻을 수 있지 않을까 싶다.<br>\n이중 로그인의 핵심은 <strong>접근자의 고유 값을 구분함</strong>이다.</p>\n<p>이렇게 복잡하게 안해도 <a href=\"https://stackoverflow.com/questions/105034/how-do-i-create-a-guid-uuid\">StackOverFlow</a>에서는 <strong>crypto.randomUUID()</strong>등을 통해서 값을 만들 수 있다.<br>\n하지만 난 내 방식대로 구현을 해보고 싶어서 위와 같이 구현했다.</p>\n<p>JWT를 통해서 구현했던 분들도 이중 로그인 해결을 위해선 서버측에 정보를 써야 하는 부분은 동일하기 때문에,<br>\n결국 세션이나 디비를 활용해야 하는 부분에 대해 납득하기 어려울(?) 수 있다.</p>\n<p>물론 JWT내에 클라이언트와 서버 측 정보를 넣어서 처리할 수도 있다.<br>\n근데 이렇게 해도 결국 <strong>마지막 로그인 정보의 상태 값</strong>을 서버에서는 어딘가 들고 있어야 하는 부분은 변함이 없다.</p>\n<p>서비스가 방대해지면 다른 좋은 방법들(Redis를 통해 세션 구현 등)을 통해서 구현해야 한다.<br>\n하지만 작은 규모의 서비스라면 이런 방식들로도 쉽게(?) 해결할 수 있다.</p>\n<p>이로써 이중 로그인 해결에 대한 개인적 고민, 그리고 해결 방안에 대해 포스팅을 남겼다.<br>\n나와 비슷한 고민을 하는, 또는 자신만의 실마리를 찾는 분들께 도움이 되었으면 한다.</p>\n<p>혹시 더 좋은 방법이나, 개선점이 있다면 댓글로 알려주시면 감사하겠다.</p>","frontmatter":{"title":"23년 2월 19일 TIL & 개발노트 (이중 로그인 관련 고민과 해결)","date":"May 05, 2023"}}},"pageContext":{"slug":"/til/230219_til/","previous":{"fields":{"slug":"/til/230504_til/"},"frontmatter":{"title":"23년 5월 4일 흑우집합소 개발노트 (Daisy ui  Stat 이상현상)"}},"next":null}},"staticQueryHashes":["3128451518","903436796"]}